#pragma once
#if defined(ARENA_SERVER)
#include <queue>
#include <vector>
#include "Physics.h"
#include <common/GamePackets.h>
#include <common/network_interface.h>
#include <common/types.h>
#include <common/packet.h>

struct PlayerInput
{
	glm::vec2 moveDir;
	float jumpTimer;
	// add more when needed;
};

namespace arena
{
    // do not change
    static const int ChallengeHashSize = 1024;

    struct ServerChallengeEntry
    {
        uint64_t m_clientSalt; // generated by client in connection request
        uint64_t m_challengeSalt; // generated by server and sent back to client in challenge pkg
        double m_createdTime; // in seconds, time this challenge was created 
        double m_lastSendTime; // in seconds, the last time challenge packet is sent this client
        ENetPeer* m_peer; // the peer where connection request came from
    };

    struct ServerChallengeHash
    {
        uint32_t m_numEntries;
        uint8_t m_exists[ChallengeHashSize];
        ServerChallengeEntry m_entries[ChallengeHashSize];
        ServerChallengeHash()
        {
            memset(this, 0, sizeof(ServerChallengeHash));
        }
    };

    struct ClientData
    {
        ENetPeer* m_peer;
        uint64_t m_clientSalt;
        uint64_t m_challengeSalt;
        double m_connectTime;
        double m_lastPacketSendTime;
        double m_lastPacketReceiveTime;

        ClientData()
        {
            memset(this, 0, sizeof(ClientData));
        }
    };

    class Server
    {
    public:
        static const uint32_t MaxClients = 32;

        Server();
        ~Server();
        void start(const String& iniPath);
        void start(uint16_t port, unsigned playerAmount);
    private:
        // returns UINT32_MAX if not found
        uint32_t findExistingClientIndex(ENetPeer* host, uint64_t clientSalt, uint64_t challengeSalt) const;

        void receivePackets(double timestamp);

        // process funcs
        void processConnectionRequest(ConnectionRequestPacket* packet, ENetPeer* from, double timestamp);

        void processConnectionResponse(ConnectionResponsePacket* packet, ENetPeer* from, double timestamp);

        void processConnectionKeepAlive(ConnectionKeepAlivePacket* packet, ENetPeer* from, double timestamp);

        void resetClient(uint32_t clientIndex);

        bool isConnected(uint64_t clientSalt, ENetPeer* peer);

        ServerChallengeEntry* findOrInsertChallenge(ENetPeer* from, uint64_t clientSalt, double timestamp);

        ServerChallengeEntry* findChallenge(ENetPeer* from, uint64_t clientSalt);

        // return UINT32_MAX if no free indices
        uint32_t findFreeClientIndex();

        void connectClient(uint32_t clientIndex, ENetPeer* peer, uint64_t clientSalt, uint64_t challengeSalt, double connectTime);

        void disconnectClient(uint32_t clientIndex, double timestamp);

        void sendPacketToConnectedClient(uint32_t clientIndex, Packet* packet, double timestamp);
    private:
        NetworkInterface* m_networkInterface;

        uint64_t m_serverSalt; // server salt

        ENetPeer* m_clientPeers[MaxClients]; // peers per client
        bool m_clientConnected[MaxClients]; // is client connected
        uint64_t m_clientSalt[MaxClients]; // client salts per client
        uint64_t m_challengeSalt[MaxClients]; // challenge salts per client
        ClientData m_clientData[MaxClients]; // client data per client

        uint32_t m_clientsConnected; // number of clients connected
        ServerChallengeHash m_challengeHash; // challenge hashes
#if 0
        // Networking game related.
        uint32_t m_updateSize;  //update packet size wont change during gameloop. 
        unsigned char* m_updateMemory; // memory set for update packet.

        void handleClientMessages();
        void handleMessage(Message &message);
        void sendPlatformPackets();
        // Gameplay
        // Pushes back bullets on m_bulletVector.
        void createOutputBullets(std::vector<BulletInputData> &bulletInputVector, unsigned playerId);

        // Networking low level.
        Network m_network;

        // Game entities.
        Physics m_physics;

        // Game Initiazation stuff
        void createPlayerInputs(unsigned playerAmount);
        void createGladiators(unsigned playerAmount);
        void sendSetupPackets(unsigned playerAmount);

        // Game loop stuff
        void gladiatorMovement();
        void sendBulletCreationEvents();
        void sendBulletHitEvents();
        void sendGameUpdateMessages();
        //  TODO: Make different respawn system later
        void respawnDeadPlayers();

        ScoreBoard m_scoreBoard;
        std::vector<GladiatorData> m_gladiatorVector;
        std::vector<BulletOutputData> m_bulletOutputVector;
        std::queue<Message>* m_messageQueue;
        std::vector<PlayerInput> m_playerInputVector;
        std::vector<Platform> m_platformVector;

        unsigned m_playerAmount;
        void loadPlatformsFromFile(char* filename);
        bool m_run;
#endif
    };
}
#endif