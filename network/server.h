#pragma once
#if defined(ARENA_SERVER)
#include <queue>
#include <vector>
#include <common/game_vars.h>
#include <common/GamePackets.h>
#include <common/network_interface.h>
#include <common/types.h>
#include <common/packet.h>

struct PlayerInput
{
	glm::vec2 moveDir;
	float jumpTimer;
	// add more when needed;
};

namespace arena
{
    // do not change
    static const int ChallengeHashSize = 1024;

    struct ServerChallengeEntry
    {
        uint64_t m_clientSalt; // generated by client in connection request
        uint64_t m_challengeSalt; // generated by server and sent back to client in challenge pkg
        double m_createdTime; // in seconds, time this challenge was created 
        double m_lastSendTime; // in seconds, the last time challenge packet is sent this client
        ENetPeer* m_peer; // the peer where connection request came from
    };

    struct ServerChallengeHash
    {
        uint32_t m_numEntries;
        uint8_t m_exists[ChallengeHashSize];
        ServerChallengeEntry m_entries[ChallengeHashSize];
        ServerChallengeHash()
        {
            memset(this, 0, sizeof(ServerChallengeHash));
        }
    };

    struct ClientData
    {
        ENetPeer* m_peer;
        uint64_t m_clientSalt;
        uint64_t m_challengeSalt;
        double m_connectTime;
        double m_lastPacketSendTime;
        double m_lastPacketReceiveTime;

        ClientData()
        {
            memset(this, 0, sizeof(ClientData));
        }
    };

    class Server
    {
    public:
        static const uint32_t MaxClients = 32;

        Server();
        ~Server();
        void start(const String& iniPath);
        void start(uint16_t port, unsigned playerAmount);
    private:
        // returns UINT32_MAX if not found
        uint32_t findExistingClientIndex(ENetPeer* host, uint64_t clientSalt, uint64_t challengeSalt) const;

        void receivePackets(double timestamp);

        // process funcs
        void processConnectionRequest(ConnectionRequestPacket* packet, ENetPeer* from, double timestamp);

        void processConnectionResponse(ConnectionResponsePacket* packet, ENetPeer* from, double timestamp);

        void processConnectionKeepAlive(ConnectionKeepAlivePacket* packet, ENetPeer* from, double timestamp);

        void processConnectionDisconnect(ConnectionDisconnectPacket* packet, ENetPeer* from, double timestamp);

        void resetClient(uint32_t clientIndex);

        bool isConnected(uint64_t clientSalt, ENetPeer* peer);

        ServerChallengeEntry* findOrInsertChallenge(ENetPeer* from, uint64_t clientSalt, double timestamp);

        ServerChallengeEntry* findChallenge(ENetPeer* from, uint64_t clientSalt);

        // return UINT32_MAX if no free indices
        uint32_t findFreeClientIndex();

        void connectClient(uint32_t clientIndex, ENetPeer* peer, uint64_t clientSalt, uint64_t challengeSalt, double connectTime);

        void disconnectClient(uint32_t clientIndex, double timestamp);

        void sendPacketToConnectedClient(uint32_t clientIndex, Packet* packet, double timestamp);
    private:
		//GameVars m_gameVars;

		void updateGameRules(const float64 dt);

        NetworkInterface* m_networkInterface;

        uint64_t m_serverSalt; // server salt

        ENetPeer* m_clientPeers[MaxClients]; // peers per client
        bool m_clientConnected[MaxClients]; // is client connected
        uint64_t m_clientSalt[MaxClients]; // client salts per client
        uint64_t m_challengeSalt[MaxClients]; // challenge salts per client
        ClientData m_clientData[MaxClients]; // client data per client

        uint32_t m_clientsConnected; // number of clients connected
        ServerChallengeHash m_challengeHash; // challenge hashes
    };
}
#endif